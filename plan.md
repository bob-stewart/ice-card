Ok, so first we have to add some authentication.

Your hid for your card? Boom, that's your identity now. Why not.

Let's keep the authentication out of the server, keep in cryptographic, in the
blockchain. It just feels right.

Something like

	card: {
		"you" : {etc}
		etc
		"private" : ENCRYPTEDJSONWITHAES({
			"otherkeys" : {
				"uid" : "[scrambled part of an AES key]"
			}
			"notes" : "etc"
			etc
		})
	}

(Using JSON for all this is starting to feel very limiting... rethink?)

So then you have an AES key with your card! It's stored... nowhere. It's
printed out on the /print sheet, and you're advised to keep it. If you lose it,
it's also been scattered into your referrers' cards.

In order to do that, we probably want some sense of consistent identity. For
one thing we have the referrals, which we could use to make IDs.... except that
people might change things. You might have to do a fuzzy search while they
enter info, where you click on someone and the ID is internally updated. That
could be like in order of weight:
 - Email
 - Name
 - Address
 - Phone

Now. Your AES key is printed on /print for you to keep, but nowhere else...
except, if you have enough friends join, your key will be shared amongst them,
with k needed to restore it. That way, if you lose your key, it can be found.

Here's a problem. Your key was never anywhere, right? Well.... how can you
share something that doesn't exist?

One way:
Wait until enough people have signed up, then ask you to sign in and enter your
key so it can be sharded. Then those shards would in turn have to be encrypted
as well....

Here's a solution:
We use asymmetric crypto.
Everyone has:
public (stored publicly)
private (NOWHERE)
password (aes key nowhere initially)
private key ENCRYPTED with password (stored publicly)

Now here we get funky.  
I sign up, and I add a bunch of contacts not on the network  
I decide to secure it and enter password "ilikedogs"  
public = pub1luna  
private = pri1luna  
Are generated by server. Public is put in my card on fabric.  
password = ilikedogs  
Is entered by me  
privenc = ((pri1luna~ilikedogs))  
Is calculated and put on fabric. my card looks like:

	{
		etc (contacts)
		"publicKey": "pub1luna",
		"privateKeyEncrypted": "342tdt234dt"
	}

We're not anywhere yet; I still need my passcode.

As friends sign on though, now we're getting somwhere, because they now all
also have keypairs. So the next time I log on, my private key unencrypted
(calculated in the moment as I enter my password) is sharded to my number of
friends *n* (as long as n>1) and the shards encrypted with their *public keys*

Now, my friend who logs in 4th from the email, signs up and puts down all the
same contacts as I did. It recognizes the people and can *immediately* shard
their unencrypted private key to all these people.

Good? No middlemen. ~Reasonable timeframe.

This has other uses. If your contacts come together to stage a coup and decide
to make you a new person, they can do that.

This coming together would obviously have to have an easy-to-use interface.

